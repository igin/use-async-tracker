{"mappings":";;;;UAEY,yCAAY;IAAZ,yCAAY,CAAZ,yCAAY,CACtB,CAAI,SAAJ,CAAI,IAAJ,CAAI;IADM,yCAAY,CAAZ,yCAAY,CAEtB,CAAU,eAAV,CAAU,IAAV,CAAU;IAFA,yCAAY,CAAZ,yCAAY,CAGtB,CAAM,WAAN,CAAM,IAAN,CAAM;IAHI,yCAAY,CAAZ,yCAAY,CAItB,CAAS,cAAT,CAAS,IAAT,CAAS;GAJC,yCAAY,KAAZ,yCAAY;;SA4BR,yCAAiB,GAA4D,CAAC;IAC5F,KAAK,EAAE,mBAAmB,EAAE,sBAAsB,IAAI,eAAQ,CAE5D,CAAC;QAAC,MAAM,EAAE,yCAAY,CAAC,IAAI;IAAC,CAAC;IAC/B,KAAK,CAAC,QAAQ,GAAG,aAAM,CAAC,KAAK;IAE7B,KAAK,CAAC,MAAM,GAAG,kBAAW,KAAO,CAAC;QAChC,QAAQ,CAAC,OAAO,GAAG,IAAI;IACzB,CAAC,EAAE,CAAC,CAAC;IAEL,EAA0E,AAA1E,wEAA0E;IAC1E,EAA+C,AAA/C,6CAA+C;IAC/C,gBAAS,KAAO,MAAM;MAAE,CAAC;QAAA,MAAM;IAAA,CAAC;IAEhC,KAAK,CAAC,KAAK,GAAG,kBAAW,QAChB,IAAiC,GACtC,wCAAkB,CAAC,IAAI,EAAE,sBAAsB,EAAE,QAAQ;MAC3D,CAAC;QAAA,sBAAsB;IAAA,CAAC;IAG1B,MAAM,CAAC,CAAC;QACN,YAAY,EAAE,mBAAmB;eACjC,KAAK;IACP,CAAC;AACH,CAAC;AAED,EAIG,AAJH;;;;CAIG,AAJH,EAIG,gBACY,wCAAkB,CAC/B,IAAiC,EACjC,eAAmE,EACnE,QAA8B,EAC9B,CAAC;IACD,GAAG,CAAC,CAAC;QACH,EAAE,EAAE,QAAQ,CAAC,OAAO,EAAE,CAAC;YACrB,OAAO,CAAC,IAAI,CAAC,CAAoD;YACjE,MAAM;QACR,CAAC;QAED,eAAe,CAAC,CAAC;YACb,MAAM,EAAE,yCAAY,CAAC,IAAI;QAC7B,CAAC;QAED,KAAK,CAAC,IAAI,GAAG,KAAK,CAAC,IAAI;QAEvB,EAAE,GAAG,QAAQ,CAAC,OAAO,EACnB,eAAe,CAAC,CAAC;YACf,MAAM,EAAE,yCAAY,CAAC,SAAS;kBAC9B,IAAI;QACN,CAAC;IAEL,CAAC,CAAC,KAAK,EAAE,KAAK,EAAE,CAAC;QACf,EAAE,GAAG,QAAQ,CAAC,OAAO,EACnB,eAAe,CAAC,CAAC;YACf,MAAM,EAAE,yCAAY,CAAC,MAAM;YAC3B,KAAK,EACH,KAAK,YAAY,KAAK,GAClB,KAAK,GACL,GAAG,CAAC,KAAK,CACP,CAAsE;QAEhF,CAAC;IAEL,CAAC;AACH,CAAC","sources":["src/index.ts"],"sourcesContent":["import { useCallback, useEffect, useRef, useState } from \"react\";\n\nexport enum PromiseState {\n  Idle,\n  InProgress,\n  Failed,\n  Succeeded,\n}\n\ntype PromiseTrackerState<ResponseType> =\n  | {\n      status: PromiseState.Idle;\n    }\n  | {\n      status: PromiseState.InProgress;\n    }\n  | {\n      status: PromiseState.Failed;\n      error: Error;\n    }\n  | {\n      status: PromiseState.Succeeded;\n      data: ResponseType;\n    };\n\ninterface UsePromiseTrackerReturnType<ResponseType> {\n  promiseState: PromiseTrackerState<ResponseType>,\n  track: (call: () => Promise<ResponseType>) => void\n}\n\nexport function usePromiseTracker<ResponseType>(): UsePromiseTrackerReturnType<ResponseType> {\n  const [promiseTrackerState, setPromiseTrackerState] = useState<\n    PromiseTrackerState<ResponseType>\n  >({ status: PromiseState.Idle });\n  const canceled = useRef(false);\n\n  const cancel = useCallback(() => {\n    canceled.current = true;\n  }, []);\n\n  // By default cancel the tracking when the component is unmounted to avoid\n  // setting the state of an unmounted component.\n  useEffect(() => cancel, [cancel]);\n\n  const track = useCallback(\n    async (call: () => Promise<ResponseType>) =>\n      trackAsyncFunction(call, setPromiseTrackerState, canceled),\n    [setPromiseTrackerState]\n  );\n\n  return {\n    promiseState: promiseTrackerState,\n    track,\n  };\n}\n\n/**\n * Tracks the state of the provided async function by calling\n * the provided setPromiseState function. If cancelled.current\n * is true the setPromiseState calls will be omitted.\n */\nasync function trackAsyncFunction<ResponseType>(\n  call: () => Promise<ResponseType>,\n  setPromiseState: (state: PromiseTrackerState<ResponseType>) => void,\n  canceled: { current: boolean }\n) {\n  try {\n    if (canceled.current) {\n      console.warn(\"[usePromiseTracker]: tracking promise after cancel\");\n      return;\n    }\n\n    setPromiseState({\n        status: PromiseState.Idle,\n    });\n\n    const data = await call();\n\n    if (!canceled.current) {\n      setPromiseState({\n        status: PromiseState.Succeeded,\n        data,\n      });\n    }\n  } catch (error) {\n    if (!canceled.current) {\n      setPromiseState({\n        status: PromiseState.Failed,\n        error:\n          error instanceof Error\n            ? error\n            : new Error(\n                \"[usePromiseTracker]: promise has been rejected with non error object\"\n              ),\n      });\n    }\n  }\n}\n"],"names":[],"version":3,"file":"module.js.map"}