{"mappings":"AAEA;IACE,IAAI,IAAA;IACJ,UAAU,IAAA;IACV,MAAM,IAAA;IACN,SAAS,IAAA;CACV;AAED,yBAAyB,YAAY,IACjC;IACE,MAAM,EAAE,aAAa,IAAI,CAAC;CAC3B,GACD;IACE,MAAM,EAAE,aAAa,UAAU,CAAC;CACjC,GACD;IACE,MAAM,EAAE,aAAa,MAAM,CAAC;IAC5B,KAAK,EAAE,KAAK,CAAC;CACd,GACD;IACE,MAAM,EAAE,aAAa,SAAS,CAAC;IAC/B,IAAI,EAAE,YAAY,CAAC;CACpB,CAAC;AAEN,sCAAsC,YAAY;IAChD,YAAY,EAAE,oBAAoB,YAAY,CAAC,CAAC;IAChD,KAAK,EAAE,CAAC,IAAI,EAAE,MAAM,OAAO,CAAC,YAAY,CAAC,KAAK,IAAI,CAAA;CACnD;AAED,kCAAkC,YAAY,KAAK,4BAA4B,YAAY,CAAC,CAwB3F","sources":["src/src/index.ts","src/index.ts"],"sourcesContent":[null,"import { useCallback, useEffect, useRef, useState } from \"react\";\n\nexport enum PromiseState {\n  Idle,\n  InProgress,\n  Failed,\n  Succeeded,\n}\n\ntype PromiseTrackerState<ResponseType> =\n  | {\n      status: PromiseState.Idle;\n    }\n  | {\n      status: PromiseState.InProgress;\n    }\n  | {\n      status: PromiseState.Failed;\n      error: Error;\n    }\n  | {\n      status: PromiseState.Succeeded;\n      data: ResponseType;\n    };\n\ninterface UsePromiseTrackerReturnType<ResponseType> {\n  promiseState: PromiseTrackerState<ResponseType>,\n  track: (call: () => Promise<ResponseType>) => void\n}\n\nexport function usePromiseTracker<ResponseType>(): UsePromiseTrackerReturnType<ResponseType> {\n  const [promiseTrackerState, setPromiseTrackerState] = useState<\n    PromiseTrackerState<ResponseType>\n  >({ status: PromiseState.Idle });\n  const canceled = useRef(false);\n\n  const cancel = useCallback(() => {\n    canceled.current = true;\n  }, []);\n\n  // By default cancel the tracking when the component is unmounted to avoid\n  // setting the state of an unmounted component.\n  useEffect(() => cancel, [cancel]);\n\n  const track = useCallback(\n    async (call: () => Promise<ResponseType>) =>\n      trackAsyncFunction(call, setPromiseTrackerState, canceled),\n    [setPromiseTrackerState]\n  );\n\n  return {\n    promiseState: promiseTrackerState,\n    track,\n  };\n}\n\n/**\n * Tracks the state of the provided async function by calling\n * the provided setPromiseState function. If cancelled.current\n * is true the setPromiseState calls will be omitted.\n */\nasync function trackAsyncFunction<ResponseType>(\n  call: () => Promise<ResponseType>,\n  setPromiseState: (state: PromiseTrackerState<ResponseType>) => void,\n  canceled: { current: boolean }\n) {\n  try {\n    if (canceled.current) {\n      console.warn(\"[usePromiseTracker]: tracking promise after cancel\");\n      return;\n    }\n\n    setPromiseState({\n        status: PromiseState.Idle,\n    });\n\n    const data = await call();\n\n    if (!canceled.current) {\n      setPromiseState({\n        status: PromiseState.Succeeded,\n        data,\n      });\n    }\n  } catch (error) {\n    if (!canceled.current) {\n      setPromiseState({\n        status: PromiseState.Failed,\n        error:\n          error instanceof Error\n            ? error\n            : new Error(\n                \"[usePromiseTracker]: promise has been rejected with non error object\"\n              ),\n      });\n    }\n  }\n}\n"],"names":[],"version":3,"file":"types.d.ts.map"}